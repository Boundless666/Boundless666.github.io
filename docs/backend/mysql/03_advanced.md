#### 适合建索引的情况

1. 如果`某个字段是唯一`的 推荐建立`唯一索引`

2. 经常作为`Where条件的字段`

3. 经常作为`Group By`、`Order By`的字段   多个字段可以建立联合索引 按照SQL从上到下的执行顺序添加相应的联合索引

4. `Update`、`Delete`的Where列添加索引

5. Distinct 字段

6. 多表JOIN连接操作时

   `联表的数量最好不要超过3张` 每增加一次联表  就相当于内层多增加了一次嵌套的循环

   `连接字段建立索引` 连接字段类型大小一致

   `where条件字段建立索引`

7. 使用列的类型小的字段建立索引

8. 使用字符串的前缀建立索引

   ```mysql
   # str 是表中某个字符串字段
   # pre_len 是前缀长度
   count(distinct left(str, pre_len)) / count(*) # 越接近1越好  一般值相差不大的情况下 pre_len越小越好
   ```

   `缺点` 比如在根据str排序后取前10条数据  但是前20条数据的前pre_len值都是一样的  此时前10条就不一定是表中最符合条件的前10条数据

9. 区分度较高的列建立索引

10. 使用最频繁的列放到联合索引的左侧

11. 在多个字段都要建立索引的情况下 联合索引优于单值索引

    > 通常一个表的索引数量尽量不超过`6个`

##### 最佳左前缀法则

根据创建`联合索引的字段`的**从左到右顺序**进行匹配 如果where条件中没有匹配上就此为止 匹配越多越好

#### 索引失效情况

1. 计算、函数、类型转换

2. 范围条件右边的列索引失效

   > 所以在建立联合索引时 经常用于范围查询的字段放在最右边

3. 不等于(!=)索引失效

4. is not null索引失效

   > is null不会失效
   >
   > is not null失效 可以将字段设置为不允许为空(not null) 并且可以给上默认值

5. like 通配符以%开头索引失效

   > 最好不要左侧通配符查询

6. OR 前后存在非索引列  索引失效

7. 数据库和表的字符集统一使用utf8mb4

   > 保持一致 不同的字符集比较前需要进行`转换`会造成索引失效

#### 练习

假设该表建立索引：index(a,b,c)

|                  **Where语句**                  |                  **索引是否被使用**                  |
| :---------------------------------------------: | :--------------------------------------------------: |
|                    where a=3                    |                       Y,使用a                        |
|                where a=3 and b=5                |                      Y,使用a,b                       |
|            where a=3 and b=5 and c=4            |                     Y,使用a,b,c                      |
| where b=3 或者 where b=4 and c=4 或者 where c=4 |                          N                           |
|                where a=3 and c=4                | Y,使用a 但是c没用到，因为b中间断了  考虑`最佳左前缀` |
|            where a=3 and b>4 and c=4            |    Y,使用a,b 但是没用到c,因为范围条件右侧索引失效    |
|        where a is null and b is not null        |   Y,使用a 但是没用到b 因为is not null导致索引失效    |
|                  where a != 3                   |                          N                           |
|                where abs(a) = 3                 |                          N                           |
|      `where a=3 and b like 'aa%' and c=4`       |                    Y,使用到a,b,c                     |
|       where a=3 and b like '%kk' and c=4        |                     Y,只使用到a                      |
|      where a=3 and b like 'k%k%%' and c=4       |                    Y，使用到a,b,c                    |

#### 索引优化与查询优化

多表查询时：**小的结果集驱动大的结果集**

> 结果集：匹配行数 * 行大小



能不用子查询就不要用子查询

子查询中 会将内查询结果保存到临时表中 查询后又销毁临时表 涉及到磁盘IO

另外临时表中将不会存在索引 这在大量数据集中有很大影响



##### Group By优化



##### 优化分页查询

```mysql
EXPLAIN SELECT * FROM student LIMIT 2000000,10;
```

优化思路

```mysql
EXPLAIN SELECT * FROM student t1,(select id from student order by id limit 2000000,10) t2
		WHERE t1.id = t2.id
```

首先使用了id`主键索引` 排序找出了2000000~2000010 这10条id(只选择id 为了更好的利用索引 并且减少不必要的字段)



至于原来的分页查询为啥不这样优化

```mysql
EXPLAIN SELECT * FROM student ORDER BY id LIMIT 2000000,10;
```

你可能会觉得这样子order by也用上了id的`主键索引`(聚簇索引)

但是没有... 因为你是 `select *` 查询所有字段 其它的字段没有索引 所以查询其它字段时都需要`回表`

此时优化器则会发现 还不如不用索引 进行`全表扫描`来的快 *MYSQLInnoDB引擎中数据存储时本身也是按照聚簇索引来存储的*



##### ICP

Index Condition Pushdown 索引条件下推

一般在联合查询中 联合索引中的部分索引失效的情况下 优化器会延迟失效索引的`回表`操作

会继续过滤条件之后再进行回表操作
